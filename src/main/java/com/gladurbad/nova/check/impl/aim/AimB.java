package com.gladurbad.nova.check.impl.aim;

import com.gladurbad.nova.check.Check;
import com.gladurbad.nova.check.handler.RotationHandler;
import com.gladurbad.nova.data.PlayerData;
import com.gladurbad.nova.util.buffer.Buffer;
import com.gladurbad.nova.util.location.PlayerLocation;

public class AimB extends Check implements RotationHandler {

    public AimB(PlayerData data) {
        super(data, "Aim (B)");
    }

    private final Buffer buffer = new Buffer(10);

    @Override
    public void handle(PlayerLocation to, PlayerLocation from) {
        // Get the current rotation values.
        float yaw = Math.abs(to.getYaw());
        float pitch = Math.abs(to.getPitch());

        // This check won't work that well with static rotations, exempt them.
        if (to.getPitch() == from.getPitch() || to.getYaw() == from.getYaw()) return;

        /*
         * Basically this aim check is just one of those weird value patch checks.
         * This check exists because once the GCD check became popular, clients like LiquidBounce and Rise started
         * patching GCD to avoid flagging checks like Aim A. Problem is, they use similar methods,
         * and whatever method they use is incorrect and detectable most of the time.
         *
         * A lot of closed-source anti-cheats have this check. But I think it's too easy to make a check like this
         * for it to be worth flexing anymore, so I'll just open source it.
         *
         * The way clients like to bypass GCD is by artificially rounding the yaw and pitch rotation to the
         * mouse sensitivity constant set by the client. The problem being, that it entirely removes the error
         * which is naturally generated by the client. We know that from the way the client is designed that we can
         * expect some sort of error due to frame-rate.
         *
         * Essentially, this is checking for perfect rounding to the mouse sensitivity, which is highly improbable
         * given the natural error of the client.
         *
         * P.S. This check operates using pre-processing from the MouseTracker. The MouseTracker only supports certain
         * sensitivity values, specifically the ones generated by the in-game slider. So if you modify your sensitivity
         * through options.txt, then you can probably entirely bypass this check.
         */
        float roundedYaw = yaw - (yaw % mouseTracker.getResolution());
        float roundedPitch = pitch - (pitch % mouseTracker.getResolution());

        float offsetYaw = Math.abs(yaw - roundedYaw);
        float offsetPitch = Math.abs(pitch - roundedPitch);

        if (offsetYaw == 0.0 || offsetPitch == 0.0 && !positionTracker.isTeleporting()) {
            // Still using a buffer since sometimes the error can be 0.
            if (buffer.add() > 6) fail();
        } else {
            buffer.reduce();
        }
    }
}
